# -*- coding: utf-8 -*-
"""fp3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n8ehE1O9QlpSgW1xDq3YhKxFqOoP3IkC
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import tensorflow as tf
import numpy as np
import joblib

# --- Helper functions to load data and models ---
@st.cache_resource
def load_resources(stock_ticker):
    """
    Loads all necessary models, scalers, and data for a given stock ticker.
    """
    try:
        # Load the LSTM model (file names are capitalized)
        lstm_model = tf.keras.models.load_model(f'lstm_model_{stock_ticker}.keras')

        # Load the LSTM scalers from joblib files
        feature_scaler = joblib.load(f'lstm_feature_scaler_{stock_ticker}.joblib')
        target_scaler = joblib.load(f'lstm_target_scaler_{stock_ticker}.joblib')

        # Load the GARCH model
        garch_model = joblib.load(f'garch_model_{stock_ticker}.joblib')

        # Load the actual volatility data
        df_actual = pd.read_csv(f'garch_{stock_ticker}_volatility.csv', index_col='Date', parse_dates=True)

        # Load the evaluation metrics
        metrics = joblib.load(f'{stock_ticker}_metrics.joblib')

        return lstm_model, feature_scaler, target_scaler, garch_model, df_actual, metrics

    except FileNotFoundError as e:
        st.error(f"Error: Required file not found. Please check your file names and paths.")
        st.error(f"Details: {e}")
        return None, None, None, None, None, None

def prepare_data_and_predict(lstm_model, feature_scaler, target_scaler, df_actual):
    """
    Prepares data and makes predictions using the LSTM model.
    """
    # The LSTM was trained with a lookback of 60 days
    n_steps = 60

    # Scale the latest data for prediction
    features_for_scaler = [
    'returns', 'price_ratio', 'volume_ratio', 'momentum_5', 'momentum_10',
    'hl_ratio', 'volatility_lag_1', 'volatility_lag_2', 'volatility_lag_3',
    'volatility_lag_5', 'volatility_ma_5', 'volatility_ma_10', 'volatility_std_5',
    'returns_lag_1', 'returns_lag_2', 'returns_lag_3'
]
scaled_data = feature_scaler.transform(df_actual[features_for_scaler].tail(n_steps))
    # Prepare the input sequence for prediction
X_pred = scaled_data.reshape(1, n_steps, 1)

    # Make a prediction
predicted_scaled = lstm_model.predict(X_pred)[0][0]

    # Inverse transform the prediction
predicted_volatility = target_scaler.inverse_transform([[predicted_scaled]])[0][0]

    # Create a new DataFrame for predictions for plotting
    df_pred = df_actual.copy()
    df_pred['LSTM Prediction'] = np.nan
    df_pred.iloc[-1, df_pred.columns.get_loc('LSTM Prediction')] = predicted_volatility

    return predicted_volatility, df_pred

# --- Streamlit App Layout ---
st.set_page_config(layout="wide", page_title="Volatility Prediction Dashboard")
st.title('Volatility Prediction Dashboard')

# --- Sidebar for user input ---
st.sidebar.header('Configuration')
stock_ticker = st.sidebar.selectbox('Select a stock:', ('QQQ', 'SPY'))

# --- Main content area ---
if stock_ticker:
    # Load all the data
    lstm_model, feature_scaler, target_scaler, garch_model, df_actual, metrics = load_resources(stock_ticker)

    if lstm_model and feature_scaler is not None:
        st.subheader(f'Volatility Prediction for {stock_ticker}')
        st.write('Forecasting 5-day rolling volatility using an LSTM model for comparison with GARCH.')

        # Make LSTM predictions
        predicted_volatility, df_lstm_pred = prepare_data_and_predict(lstm_model, feature_scaler, target_scaler, df_actual)

        # Generate GARCH predictions for the last day
        # The GARCH model is loaded as an arch.univariate.ARCHModelResult object
        garch_predictions = garch_model.forecast(horizon=1)
        garch_predicted_volatility = np.sqrt(garch_predictions.variance.values[-1,:][0])

        # Combine data for plotting
        combined_df = df_actual.copy()
        combined_df['LSTM Prediction'] = df_lstm_pred['LSTM Prediction']
        combined_df['GARCH Prediction'] = np.nan
        combined_df.iloc[-1, combined_df.columns.get_loc('GARCH Prediction')] = garch_predicted_volatility

        # --- Graph 1: Actual vs. LSTM Prediction ---
        st.header('Actual vs. Predicted Volatility (LSTM)')
        fig_lstm = px.line(combined_df, y=['GARCH_Volatility', 'LSTM Prediction'],
                         title=f'Actual vs. LSTM Predicted Volatility for {stock_ticker}',
                         labels={'value': 'Volatility', 'Date': 'Date'},
                         color_discrete_map={'rolling_vol_5': 'blue', 'LSTM Prediction': 'orange'})
        fig_lstm.update_layout(xaxis_title="Date", yaxis_title="Volatility")
        st.plotly_chart(fig_lstm, use_container_width=True)

        # --- Graph 2: LSTM vs. GARCH Prediction ---
        st.header('LSTM vs. GARCH Predictions')
        fig_comparison = px.line(combined_df, y=['LSTM Prediction', 'GARCH Prediction'],
                                 title=f'Comparison of LSTM and GARCH Predictions for {stock_ticker}',
                                 labels={'value': 'Predicted Volatility', 'Date': 'Date'},
                                 color_discrete_map={'LSTM Prediction': 'orange', 'GARCH Prediction': 'green'})
        fig_comparison.update_layout(xaxis_title="Date", yaxis_title="Predicted Volatility")
        st.plotly_chart(fig_comparison, use_container_width=True)

        # --- Evaluation Table ---
        st.header(f'Evaluation Scores for LSTM Model ({stock_ticker})')
        eval_df = pd.DataFrame(metrics).set_index('Metric')
        st.table(eval_df)
